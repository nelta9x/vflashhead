# Refactoring Guidelines

프로젝트 전용 지침과 별개로, 사람/AI 에이전트가 공통으로 사용할 수 있는 **범용 리팩토링 운영 가이드**입니다.

## 1) 목적
- 기능 추가 속도와 구조 안정성의 균형을 유지한다.
- \"한 번에 큰 리팩토링\"을 피하고, 작은 단위로 주기적으로 구조를 개선한다.
- 변경 반경을 줄여 회귀 위험과 디버깅 시간을 줄인다.

## 2) 리팩토링 트리거
아래 항목 중 하나라도 만족하면 리팩토링 후보로 간주한다.

- 단일 파일에 독립 책임 3개 이상이 공존한다.
- 파일 길이가 800~1000 라인 이상이다.
- 단일 메서드 길이가 80 라인 이상이다.
- 테스트가 공개 계약이 아니라 private 구현 세부에 강하게 결합돼 있다.
- 동일 파일에서 서로 다른 도메인 변경이 반복 충돌한다. (리뷰/머지 충돌 빈발)

## 3) 주기 (Cadence)
- 신규 기능 2~3개 구현마다 구조 점검을 수행한다.
- 기능 1개마다 즉시 리팩토링하는 방식은 churn 비용이 크므로 지양한다.
- 기능 4개 이상 누적 후 한 번에 정리하는 big-bang 리팩토링은 지양한다.
- 출시 직전 핫픽스/장애 대응 구간은 구조 이동을 최소화하고, 사후 정리로 이월한다.

## 4) 분리 단위: \"상태 + 타이밍 + 이벤트\"
리팩토링 단위는 단순 유틸 함수 묶음이 아니라 아래 3요소가 함께 움직이는 도메인 단위로 잡는다.

- 상태(State): 해당 기능이 소유하는 지속 데이터
  - 예: `Map`, `Array`, 쿨다운 값, phase 플래그
- 타이밍(Timing): 상태 변화 시점
  - 예: `update(delta)`, `delayedCall`, tween 콜백, interval tick
- 이벤트(Event): 외부와의 입출력 경계
  - 예: EventBus 구독/발행, 입력 이벤트, 시스템 콜백

판단 기준:
- 같은 도메인에서 위 3요소를 동시에 다루면 하나의 모듈 후보이다.
- 반대로 3요소 중 일부만 있고 도메인 경계가 불명확하면 분리를 보류한다.

## 5) 구조 원칙
- 오케스트레이터(예: Scene)는 상위 흐름만 유지한다.
  - 생성/업데이트/정리 순서, 전역 pause/resume 상태 전환, 주요 컨텍스트 조합
- 도메인 규칙은 전용 모듈로 분리한다.
  - 전투/공격/스폰/입력 바인딩/이벤트 바인딩 등
- 이벤트 payload 계약(이름/shape)은 가능한 유지한다.
- 하드코딩 수치 대신 기존 데이터 소스(SSOT)를 우선 사용한다.

## 6) 구현 순서 (권장)
1. 공유 타입/계약 인터페이스를 먼저 분리한다.
2. 바인딩 계층(이벤트/입력)부터 분리해 접점 복잡도를 낮춘다.
3. 고위험 도메인(비동기 타이밍 포함)을 하나씩 분리한다.
4. 각 단계마다 테스트를 통과시키고 다음 단계로 진행한다.
5. 최종적으로 오케스트레이터 파일에서 도메인 구현을 제거한다.

## 7) 테스트 전략
- private 메서드 호출 기반 테스트를 줄이고, 모듈 공개 API 계약 테스트로 전환한다.
- 비동기 가드 회귀를 우선 테스트한다.
  - 예: wave/scene 전환 후 delayedCall 안전성, gameOver 가드
- 기존 의미(규칙)는 유지하고 구조만 바뀌었는지 검증한다.

## 8) 완료 기준
- 정적 검사/테스트/빌드 통과
  - `npm run lint`
  - `npm run test:run`
  - `npm run build`
- 구조 변경 문서 동기화 완료
  - 구조 문서 (예: `CODEMAP.md`)
  - 교훈 문서 (예: `LESSONS.md`)
  - 작업 규칙 문서 (예: `AGENTS.md`)

## 9) 재사용(범용) 템플릿 팁
다른 프로젝트로 옮길 때는 아래만 교체하면 된다.

- 오케스트레이터 이름 (Scene / Controller / Service)
- 이벤트 시스템 이름 (EventBus / Emitter / MessageBus)
- 검증 커맨드 (lint/test/build 스크립트)
- 라인 수 임계값 (팀 규모/코드베이스에 맞춰 조정)
